{"version":3,"sources":["webpack://WebIDL2/webpack/universalModuleDefinition","webpack://WebIDL2/webpack/bootstrap","webpack://WebIDL2/./lib/webidl2.js","webpack://WebIDL2/./lib/writer.js","webpack://WebIDL2/./lib/validator.js","webpack://WebIDL2/./index.js"],"names":["root","factory","exports","module","define","amd","this","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","tokenRe","float","integer","identifier","string","whitespace","comment","other","stringTypes","argumentNameKeywords","nonRegexTerminals","concat","punctuations","WebIDLParseError","Error","[object Object]","str","line","input","tokens","super","constructor","JSON","stringify","message","parseByTokens","source","slice","current","FLOAT","INT","ID","STR","error","probe","length","consume_position","precedingLine","text","splitted","split","lastLine","tokensToText","sliceTokens","precedes","procedingTokens","procedingText","context","repeat","since","partial","type","count","Math","max","inputs","map","trivia","join","nextToken","consume","candidates","token","optional_consume","args","optional","untype_token","unvalue_token","unescape","startsWith","unconsume","position","list","parser","allowDangler","listName","first","separator","items","item","push","Definition","defineProperties","entries","json","undefined","escapedName","proto","descMap","getOwnPropertyDescriptors","getPrototypeOf","primitive_type","num_type","prefix","base","postfix","Type","integer_type","float_type","const_value","const_data","negative","type_suffix","obj","nullable","extAttrs","generic","union","idlType","subtype","filter","baseName","escapedBaseName","GenericType","typeName","ret","open","return_type","type_with_extended_attributes","keyType","keyIdlType","valueType","close","UnionType","typ","or","parse","single_type","ExtendedAttributes","Argument","start_position","variadic","default","Default","argument_list","Token","ExtendedAttributeParameters","assign","secondaryName","rhsType","ids","identifiers","hasRhs","SimpleExtendedAttribute","params","rhs","Array","isArray","signature","arguments","def","expression","second","Constant","termination","CallbackFunction","Attribute","special","noInherit","readonly","voidToken","OperationBody","escaped","Operation","regular","body","static_member","stringifier","IterableLike","secondTypeRequired","secondTypeAllowed","Inheritance","colon","Container","instance","inheritable","allowedMembers","inheritance","members","ea","mem","Interface","callback","Mixin","mixin","interface_","opts","Namespace","Dictionary","Field","required","Enum","values","EnumValue","Typedef","Includes","target","includes","index","escapedTarget","escapedIncludes","definition","tok","res","defs","definitions","lastCharIndex","nextChar","charAt","result","test","attemptTokenMatch","noFlushTrivia","currentTrivia","pop","match","punctuation","re","lastIndex","exec","tokenise","noop","arg","templates","wrap","reference","extendedAttribute","extendedAttributeReference","write","ast","ts","strings","raw","unescaped","extract_trivia","batch","reference_token","name_token","it","extended_attributes","subtypes","genericName","gTrivia","type_body","default_","argument","data","id","make_ext_at","eats","container","inh","iterate","iterable_like","parent","table","interface","interface mixin","namespace","operation","attribute","dictionary","field","const","typedef","enum","enum-value","v","iterable","legacyiterable","maplike","setlike","callback interface","eof","things","results","thing","dispatch","checkDuplicatedNames","unique","duplicates","dup","checkInterfaceMemberDuplication","interfaces","includesMap","Map","all","include","array","set","getIncludesMap","forEachInterface","opNames","Set","getOperations","op","partials","mixins","ext","additions","forEachExtension","addition","add","existings","has","validate","groupDefinitions","__webpack_exports__"],"mappings":"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","file":"webidl2.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"WebIDL2\"] = factory();\n\telse\n\t\troot[\"WebIDL2\"] = factory();\n})(this, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","\"use strict\";\r\n\r\n// These regular expressions use the sticky flag so they will only match at\r\n// the current location (ie. the offset of lastIndex).\r\nconst tokenRe = {\r\n  // This expression uses a lookahead assertion to catch false matches\r\n  // against integers early.\r\n  \"float\": /-?(?=[0-9]*\\.|[0-9]+[eE])(([0-9]+\\.[0-9]*|[0-9]*\\.[0-9]+)([Ee][-+]?[0-9]+)?|[0-9]+[Ee][-+]?[0-9]+)/y,\r\n  \"integer\": /-?(0([Xx][0-9A-Fa-f]+|[0-7]*)|[1-9][0-9]*)/y,\r\n  \"identifier\": /[_-]?[A-Za-z][0-9A-Z_a-z-]*/y,\r\n  \"string\": /\"[^\"]*\"/y,\r\n  \"whitespace\": /[\\t\\n\\r ]+/y,\r\n  \"comment\": /((\\/(\\/.*|\\*([^*]|\\*[^/])*\\*\\/)[\\t\\n\\r ]*)+)/y,\r\n  \"other\": /[^\\t\\n\\r 0-9A-Za-z]/y\r\n};\r\n\r\nconst stringTypes = [\r\n  \"ByteString\",\r\n  \"DOMString\",\r\n  \"USVString\"\r\n];\r\n\r\nconst argumentNameKeywords = [\r\n  \"attribute\",\r\n  \"callback\",\r\n  \"const\",\r\n  \"deleter\",\r\n  \"dictionary\",\r\n  \"enum\",\r\n  \"getter\",\r\n  \"includes\",\r\n  \"inherit\",\r\n  \"interface\",\r\n  \"iterable\",\r\n  \"maplike\",\r\n  \"namespace\",\r\n  \"partial\",\r\n  \"required\",\r\n  \"setlike\",\r\n  \"setter\",\r\n  \"static\",\r\n  \"stringifier\",\r\n  \"typedef\",\r\n  \"unrestricted\"\r\n];\r\n\r\nconst nonRegexTerminals = [\r\n  \"-Infinity\",\r\n  \"FrozenArray\",\r\n  \"Infinity\",\r\n  \"NaN\",\r\n  \"Promise\",\r\n  \"boolean\",\r\n  \"byte\",\r\n  \"double\",\r\n  \"false\",\r\n  \"float\",\r\n  \"implements\",\r\n  \"legacyiterable\",\r\n  \"long\",\r\n  \"mixin\",\r\n  \"null\",\r\n  \"octet\",\r\n  \"optional\",\r\n  \"or\",\r\n  \"readonly\",\r\n  \"record\",\r\n  \"sequence\",\r\n  \"short\",\r\n  \"true\",\r\n  \"unsigned\",\r\n  \"void\"\r\n].concat(argumentNameKeywords, stringTypes);\r\n\r\nconst punctuations = [\r\n  \"(\",\r\n  \")\",\r\n  \",\",\r\n  \"...\",\r\n  \":\",\r\n  \";\",\r\n  \"<\",\r\n  \"=\",\r\n  \">\",\r\n  \"?\",\r\n  \"[\",\r\n  \"]\",\r\n  \"{\",\r\n  \"}\"\r\n];\r\n\r\nfunction tokenise(str) {\r\n  const tokens = [];\r\n  let lastCharIndex = 0;\r\n  let trivia = \"\";\r\n  let line = 1;\r\n  let index = 0;\r\n  while (lastCharIndex < str.length) {\r\n    const nextChar = str.charAt(lastCharIndex);\r\n    let result = -1;\r\n\r\n    if (/[\\t\\n\\r ]/.test(nextChar)) {\r\n      result = attemptTokenMatch(\"whitespace\", { noFlushTrivia: true });\r\n    } else if (nextChar === '/') {\r\n      result = attemptTokenMatch(\"comment\", { noFlushTrivia: true });\r\n    }\r\n\r\n    if (result !== -1) {\r\n      const currentTrivia = tokens.pop().value;\r\n      line += (currentTrivia.match(/\\n/g) || []).length;\r\n      trivia += currentTrivia;\r\n      index -= 1;\r\n    } else if (/[-0-9.A-Z_a-z]/.test(nextChar)) {\r\n      result = attemptTokenMatch(\"float\");\r\n      if (result === -1) {\r\n        result = attemptTokenMatch(\"integer\");\r\n      }\r\n      if (result === -1) {\r\n        result = attemptTokenMatch(\"identifier\");\r\n        const token = tokens[tokens.length - 1];\r\n        if (result !== -1 && nonRegexTerminals.includes(token.value)) {\r\n          token.type = token.value;\r\n        }\r\n      }\r\n    } else if (nextChar === '\"') {\r\n      result = attemptTokenMatch(\"string\");\r\n    }\r\n\r\n    for (const punctuation of punctuations) {\r\n      if (str.startsWith(punctuation, lastCharIndex)) {\r\n        tokens.push({ type: punctuation, value: punctuation, trivia, line, index });\r\n        trivia = \"\";\r\n        lastCharIndex += punctuation.length;\r\n        result = lastCharIndex;\r\n        break;\r\n      }\r\n    }\r\n\r\n    // other as the last try\r\n    if (result === -1) {\r\n      result = attemptTokenMatch(\"other\");\r\n    }\r\n    if (result === -1) {\r\n      throw new Error(\"Token stream not progressing\");\r\n    }\r\n    lastCharIndex = result;\r\n    index += 1;\r\n  }\r\n\r\n  // remaining trivia as eof\r\n  tokens.push({\r\n    type: \"eof\",\r\n    value: \"\",\r\n    trivia\r\n  });\r\n\r\n  return tokens;\r\n\r\n  function attemptTokenMatch(type, { noFlushTrivia } = {}) {\r\n    const re = tokenRe[type];\r\n    re.lastIndex = lastCharIndex;\r\n    const result = re.exec(str);\r\n    if (result) {\r\n      tokens.push({ type, value: result[0], trivia, line, index });\r\n      if (!noFlushTrivia) {\r\n        trivia = \"\";\r\n      }\r\n      return re.lastIndex;\r\n    }\r\n    return -1;\r\n  }\r\n}\r\n\r\nclass WebIDLParseError extends Error {\r\n  constructor(str, line, input, tokens) {\r\n    super(str);\r\n    this.name = this.constructor.name;\r\n    this.line = line;\r\n    this.input = input;\r\n    this.tokens = tokens;\r\n  }\r\n\r\n  toString() {\r\n    const tokens = JSON.stringify(this.tokens, null, 4);\r\n    return `${this.message}\\n${tokens}`;\r\n  }\r\n}\r\n\r\nfunction parseByTokens(source) {\r\n  source = source.slice();\r\n  let current = null;\r\n\r\n  const FLOAT = \"float\";\r\n  const INT = \"integer\";\r\n  const ID = \"identifier\";\r\n  const STR = \"string\";\r\n\r\n  function error(str) {\r\n    const maxTokens = 5;\r\n    const line =\r\n      !probe(\"eof\") ? source[consume_position].line :\r\n      source.length > 1 ? source[consume_position - 1].line :\r\n      1;\r\n\r\n    const precedingLine = lastLine(\r\n      tokensToText(sliceTokens(-maxTokens), { precedes: true })\r\n    );\r\n\r\n    const procedingTokens = sliceTokens(maxTokens);\r\n    const procedingText = tokensToText(procedingTokens);\r\n    const procedingLine = procedingText.split(\"\\n\")[0];\r\n\r\n    const spaced = \" \".repeat(precedingLine.length) + \"^ \" + str;\r\n    const context = precedingLine + procedingLine + \"\\n\" + spaced;\r\n\r\n    const since = current ? `, since \\`${current.partial ? \"partial \" : \"\"}${current.type} ${current.name}\\`` : \"\";\r\n    const message = `Syntax error at line ${line}${since}:\\n${context}`;\r\n\r\n    throw new WebIDLParseError(message, line, procedingText, procedingTokens);\r\n\r\n    function sliceTokens(count) {\r\n      return count > 0 ?\r\n        source.slice(consume_position, consume_position + count) :\r\n        source.slice(Math.max(consume_position + count, 0), consume_position);\r\n    }\r\n\r\n    function tokensToText(inputs, { precedes } = {}) {\r\n      const text = inputs.map(t => t.trivia + t.value).join(\"\");\r\n      const nextToken = source[consume_position];\r\n      if (nextToken.type === \"eof\") {\r\n        return text;\r\n      }\r\n      if (precedes) {\r\n        return text + nextToken.trivia;\r\n      }\r\n      return text.slice(nextToken.trivia.length);\r\n    }\r\n\r\n    function lastLine(text) {\r\n      const splitted = text.split(\"\\n\");\r\n      return splitted[splitted.length - 1];\r\n    }\r\n  }\r\n\r\n  let consume_position = 0;\r\n\r\n  function probe(type) {\r\n    return source.length > consume_position && source[consume_position].type === type;\r\n  }\r\n\r\n  function consume(...candidates) {\r\n    // TODO: use const when Servo updates its JS engine\r\n    // eslint-disable-next-line prefer-const\r\n    for (let type of candidates) {\r\n      if (!probe(type)) continue;\r\n      const token = source[consume_position];\r\n      consume_position++;\r\n      return token;\r\n    }\r\n  }\r\n\r\n  function optional_consume(...args) {\r\n    const token = consume(...args);\r\n    if (token) {\r\n      token.optional = true;\r\n    }\r\n    return token;\r\n  }\r\n\r\n  function untype_token(token) {\r\n    if (!token) {\r\n      return null;\r\n    }\r\n    const { value, trivia } = token;\r\n    return { value, trivia };\r\n  }\r\n\r\n  function unvalue_token(token) {\r\n    if (!token) {\r\n      return null;\r\n    }\r\n    const { trivia } = token;\r\n    return { trivia };\r\n  }\r\n\r\n  function unescape(identifier) {\r\n    return identifier.startsWith('_') ? identifier.slice(1) : identifier;\r\n  }\r\n\r\n  function unconsume(position) {\r\n    consume_position = position;\r\n  }\r\n\r\n  /**\r\n   * Parses comma-separated list\r\n   * @param {object} args\r\n   * @param {Function} args.parser parser function for each item\r\n   * @param {boolean} [args.allowDangler] whether to allow dangling comma\r\n   * @param {string} [args.listName] the name to be shown on error messages\r\n   */\r\n  function list({ parser, allowDangler, listName = \"list\" }) {\r\n    const first = parser();\r\n    if (!first) {\r\n      return [];\r\n    }\r\n    first.tokens.separator = optional_consume(\",\");\r\n    const items = [first];\r\n    while (first.tokens.separator) {\r\n      const item = parser();\r\n      if (!item) {\r\n        if (!allowDangler) {\r\n          error(`Trailing comma in ${listName}`);\r\n        }\r\n        break;\r\n      }\r\n      item.tokens.separator = optional_consume(\",\");\r\n      items.push(item);\r\n      if (!item.tokens.separator) break;\r\n    }\r\n    return items;\r\n  }\r\n\r\n  class Definition {\r\n    constructor({ tokens }) {\r\n      Object.defineProperties(this, {\r\n        source: { value: source },\r\n        tokens: { value: tokens }\r\n      });\r\n    }\r\n\r\n    get trivia() {\r\n      const object = {};\r\n      for (const [key, value] of Object.entries(this.tokens)) {\r\n        if (value && !value.optional) {\r\n          object[key] = value.trivia;\r\n        }\r\n      }\r\n      return object;\r\n    }\r\n\r\n    toJSON() {\r\n      const json = { type: undefined, name: undefined, escapedName: undefined };\r\n      let proto = this;\r\n      while (proto !== Object.prototype) {\r\n        const descMap = Object.getOwnPropertyDescriptors(proto);\r\n        for (const [key, value] of Object.entries(descMap)) {\r\n          if (value.enumerable || value.get) {\r\n            json[key] = this[key];\r\n          }\r\n        }\r\n        proto = Object.getPrototypeOf(proto);\r\n      }\r\n      return json;\r\n    }\r\n  }\r\n\r\n  function integer_type() {\r\n    const prefix = optional_consume(\"unsigned\");\r\n    const base = consume(\"short\", \"long\");\r\n    if (base) {\r\n      const postfix = optional_consume(\"long\");\r\n      return new Type({ tokens: { prefix, base, postfix } });\r\n    }\r\n    if (prefix) error(\"Failed to parse integer type\");\r\n  }\r\n\r\n  function float_type() {\r\n    const prefix = optional_consume(\"unrestricted\");\r\n    const base = consume(\"float\", \"double\");\r\n    if (base) {\r\n      return new Type({ tokens: { prefix, base } });\r\n    }\r\n    if (prefix) error(\"Failed to parse float type\");\r\n  }\r\n\r\n  function primitive_type() {\r\n    const num_type = integer_type() || float_type();\r\n    if (num_type) return num_type;\r\n    const base = consume(\"boolean\", \"byte\", \"octet\");\r\n    if (base) {\r\n      return new Type({ tokens: { base } });\r\n    }\r\n  }\r\n\r\n  function const_value() {\r\n    return consume(\"true\", \"false\", \"Infinity\", \"-Infinity\", \"NaN\", FLOAT, INT);\r\n  }\r\n\r\n  function const_data(token) {\r\n    switch (token.type) {\r\n      case \"true\":\r\n      case \"false\":\r\n        return { type: \"boolean\", value: token.type === \"true\" };\r\n      case \"Infinity\":\r\n      case \"-Infinity\":\r\n        return { type: \"Infinity\", negative: token.type.startsWith(\"-\") };\r\n      case FLOAT:\r\n      case INT:\r\n        return { type: \"number\", value: token.value };\r\n      case \"[\":\r\n        return { type: \"sequence\", value: [] };\r\n      case STR:\r\n        return { type: STR, value: token.value.slice(1, -1) };\r\n      default:\r\n        return { type: token.type };\r\n    }\r\n  }\r\n\r\n  function type_suffix(obj) {\r\n    const nullable = optional_consume(\"?\");\r\n    if (nullable) {\r\n      obj.tokens.nullable = nullable;\r\n    }\r\n    if (probe(\"?\")) error(\"Can't nullable more than once\");\r\n  }\r\n\r\n  class Type extends Definition {\r\n    constructor({ tokens }) {\r\n      super({ tokens });\r\n      Object.defineProperty(this, \"subtype\", { value: [] });\r\n      this.extAttrs = null;\r\n    }\r\n\r\n    get generic() {\r\n      return null;\r\n    }\r\n    get nullable() {\r\n      return unvalue_token(this.tokens.nullable);\r\n    }\r\n    get union() {\r\n      return false;\r\n    }\r\n    get idlType() {\r\n      if (this.subtype.length) {\r\n        return this.subtype;\r\n      }\r\n      // Adding prefixes/postfixes for \"unrestricted float\", etc.\r\n      const name = [\r\n        this.tokens.prefix,\r\n        this.tokens.base,\r\n        this.tokens.postfix\r\n      ].filter(t => t).map(t => t.value).join(\" \");\r\n      return unescape(name);\r\n    }\r\n    get baseName() {\r\n      const { escapedBaseName } = this;\r\n      if (!escapedBaseName) {\r\n        return null;\r\n      }\r\n      return unescape(escapedBaseName);\r\n    }\r\n    get escapedBaseName() {\r\n      if (!this.tokens.base) {\r\n        return null;\r\n      }\r\n      return this.tokens.base.value;\r\n    }\r\n    get prefix() {\r\n      return untype_token(this.tokens.prefix);\r\n    }\r\n    get postfix() {\r\n      return untype_token(this.tokens.postfix);\r\n    }\r\n    get separator() {\r\n      return untype_token(this.tokens.separator);\r\n    }\r\n  }\r\n\r\n  class GenericType extends Type {\r\n    static parse(typeName) {\r\n      const base = consume(\"FrozenArray\", \"Promise\", \"sequence\", \"record\");\r\n      if (!base) {\r\n        return;\r\n      }\r\n      const ret = new GenericType({ tokens: { base } });\r\n      ret.tokens.open = optional_consume(\"<\") || error(`No opening bracket after ${base.type}`);\r\n      switch (base.type) {\r\n        case \"Promise\": {\r\n          if (probe(\"[\")) error(\"Promise type cannot have extended attribute\");\r\n          const subtype = return_type(typeName) || error(\"Missing Promise subtype\");\r\n          ret.subtype.push(subtype);\r\n          break;\r\n        }\r\n        case \"sequence\":\r\n        case \"FrozenArray\": {\r\n          const subtype = type_with_extended_attributes(typeName) || error(`Missing ${base.type} subtype`);\r\n          ret.subtype.push(subtype);\r\n          break;\r\n        }\r\n        case \"record\": {\r\n          if (probe(\"[\")) error(\"Record key cannot have extended attribute\");\r\n          const keyType = consume(...stringTypes) || error(`Record key must be one of: ${stringTypes.join(\", \")}`);\r\n          const keyIdlType = new Type({ tokens: { base: keyType }});\r\n          keyIdlType.tokens.separator = optional_consume(\",\") || error(\"Missing comma after record key type\");\r\n          keyIdlType.type = typeName;\r\n          const valueType = type_with_extended_attributes(typeName) || error(\"Error parsing generic type record\");\r\n          ret.subtype.push(keyIdlType, valueType);\r\n          break;\r\n        }\r\n      }\r\n      if (!ret.idlType) error(`Error parsing generic type ${base.type}`);\r\n      ret.tokens.close = optional_consume(\">\") || error(`Missing closing bracket after ${base.type}`);\r\n      return ret;\r\n    }\r\n\r\n    get generic() {\r\n      return {\r\n        value: this.baseName,\r\n        trivia: {\r\n          open: this.tokens.open.trivia,\r\n          close: this.tokens.close.trivia,\r\n        }\r\n      };\r\n    }\r\n  }\r\n\r\n  function single_type(typeName) {\r\n    let ret = GenericType.parse(typeName) || primitive_type();\r\n    if (!ret) {\r\n      const base = consume(ID, ...stringTypes);\r\n      if (!base) {\r\n        return;\r\n      }\r\n      ret = new Type({ tokens: { base } });\r\n      if (probe(\"<\")) error(`Unsupported generic type ${base.value}`);\r\n    }\r\n    if (ret.generic && ret.generic.value === \"Promise\" && probe(\"?\")) {\r\n      error(\"Promise type cannot be nullable\");\r\n    }\r\n    ret.type = typeName || null;\r\n    type_suffix(ret);\r\n    if (ret.nullable && ret.idlType === \"any\") error(\"Type `any` cannot be made nullable\");\r\n    return ret;\r\n  }\r\n\r\n  class UnionType extends Type {\r\n    static parse(type) {\r\n      const tokens = {};\r\n      tokens.open = consume(\"(\");\r\n      if (!tokens.open) return;\r\n      const ret = new UnionType({ tokens });\r\n      ret.type = type || null;\r\n      while (true) {\r\n        const typ = type_with_extended_attributes() || error(\"No type after open parenthesis or 'or' in union type\");\r\n        if (typ.idlType === \"any\") error(\"Type `any` cannot be included in a union type\");\r\n        ret.subtype.push(typ);\r\n        const or = optional_consume(\"or\");\r\n        if (or) {\r\n          typ.tokens.separator = or;\r\n        }\r\n        else break;\r\n      }\r\n      if (ret.idlType.length < 2) {\r\n        error(\"At least two types are expected in a union type but found less\");\r\n      }\r\n      tokens.close = consume(\")\") || error(\"Unterminated union type\");\r\n      type_suffix(ret);\r\n      return ret;\r\n    }\r\n\r\n    get union() {\r\n      return true;\r\n    }\r\n  }\r\n\r\n  function type(typeName) {\r\n    return single_type(typeName) || UnionType.parse(typeName);\r\n  }\r\n\r\n  function type_with_extended_attributes(typeName) {\r\n    const extAttrs = ExtendedAttributes.parse();\r\n    const ret = type(typeName);\r\n    if (ret) ret.extAttrs = extAttrs;\r\n    return ret;\r\n  }\r\n\r\n  class Argument extends Definition {\r\n    static parse() {\r\n      const start_position = consume_position;\r\n      const tokens = {};\r\n      const ret = new Argument({ tokens });\r\n      tokens.optional = optional_consume(\"optional\");\r\n      ret.idlType = type_with_extended_attributes(\"argument-type\");\r\n      if (!ret.idlType) {\r\n        return unconsume(start_position);\r\n      }\r\n      if (!tokens.optional) {\r\n        tokens.variadic = optional_consume(\"...\");\r\n      }\r\n      tokens.name = consume(ID, ...argumentNameKeywords);\r\n      if (!tokens.name) {\r\n        return unconsume(start_position);\r\n      }\r\n      ret.default = tokens.optional ? Default.parse() : null;\r\n      return ret;\r\n    }\r\n\r\n    get optional() {\r\n      return unvalue_token(this.tokens.optional);\r\n    }\r\n    get variadic() {\r\n      return unvalue_token(this.tokens.variadic);\r\n    }\r\n    get name() {\r\n      return unescape(this.escapedName);\r\n    }\r\n    get escapedName() {\r\n      return this.tokens.name.value;\r\n    }\r\n    get separator() {\r\n      return untype_token(this.tokens.separator);\r\n    }\r\n  }\r\n\r\n  function argument_list() {\r\n    return list({ parser: Argument.parse, listName: \"arguments list\" });\r\n  }\r\n\r\n  class Token extends Definition {\r\n    /**\r\n     * @param {string} type\r\n     */\r\n    static parser(type) {\r\n      return () => {\r\n        const value = consume(type);\r\n        if (value) {\r\n          return new Token({ tokens: { value } });\r\n        }\r\n      };\r\n    }\r\n\r\n    get value() {\r\n      return this.tokens.value.value;\r\n    }\r\n    get trivia() {\r\n      return this.tokens.value.trivia;\r\n    }\r\n    get separator() {\r\n      return untype_token(this.tokens.separator);\r\n    }\r\n  }\r\n\r\n  function identifiers() {\r\n    const ids = list({ parser: Token.parser(ID), listName: \"identifier list\" });\r\n    if (!ids.length) {\r\n      error(\"Expected identifiers but none found\");\r\n    }\r\n    return ids;\r\n  }\r\n\r\n  class ExtendedAttributeParameters extends Definition {\r\n    static parse() {\r\n      const tokens = { assign: consume(\"=\") };\r\n      const ret = new ExtendedAttributeParameters({ tokens });\r\n      if (tokens.assign) {\r\n        tokens.secondaryName = optional_consume(ID, FLOAT, INT, STR);\r\n      }\r\n      tokens.open = consume(\"(\");\r\n      if (tokens.open) {\r\n        ret.list = ret.rhsType === \"identifier-list\" ?\r\n          // [Exposed=(Window,Worker)]\r\n          identifiers() :\r\n          // [NamedConstructor=Audio(DOMString src)] or [Constructor(DOMString str)]\r\n          argument_list();\r\n        tokens.close = consume(\")\") || error(\"Unexpected token in extended attribute argument list\");\r\n      } else if (ret.hasRhs && !tokens.secondaryName) {\r\n        error(\"No right hand side to extended attribute assignment\");\r\n      }\r\n      return ret;\r\n    }\r\n\r\n    get rhsType() {\r\n      return !this.tokens.assign ? null :\r\n        !this.tokens.secondaryName ? \"identifier-list\" :\r\n        this.tokens.secondaryName.type;\r\n    }\r\n  }\r\n\r\n  class SimpleExtendedAttribute extends Definition {\r\n    static parse() {\r\n      const name = consume(ID);\r\n      if (name) {\r\n        return new SimpleExtendedAttribute({\r\n          tokens: { name },\r\n          params: ExtendedAttributeParameters.parse()\r\n        });\r\n      }\r\n    }\r\n\r\n    constructor({ tokens, params }) {\r\n      super({ tokens });\r\n      Object.defineProperty(this, \"params\", { value: params });\r\n    }\r\n\r\n    get type() {\r\n      return \"extended-attribute\";\r\n    }\r\n    get name() {\r\n      return this.tokens.name.value;\r\n    }\r\n    get rhs() {\r\n      const { rhsType: type, tokens, list, trivia } = this.params;\r\n      if (!type) {\r\n        return null;\r\n      }\r\n      const value = type === \"identifier-list\" ? list : tokens.secondaryName.value;\r\n      if (!Array.isArray(value)) {\r\n        trivia.value = tokens.secondaryName.trivia;\r\n        trivia.open = trivia.close = undefined;\r\n      }\r\n      return { type, value, trivia };\r\n    }\r\n    get signature() {\r\n      const { rhsType, list, trivia } = this.params;\r\n      if (!list || rhsType === \"identifier-list\") {\r\n        return null;\r\n      }\r\n      trivia.assign = undefined;\r\n      return { arguments: list, trivia };\r\n    }\r\n    get separator() {\r\n      return untype_token(this.tokens.separator);\r\n    }\r\n  }\r\n\r\n  // Note: we parse something simpler than the official syntax. It's all that ever\r\n  // seems to be used\r\n  class ExtendedAttributes extends Definition {\r\n    static parse() {\r\n      const tokens = {};\r\n      tokens.open = consume(\"[\");\r\n      if (!tokens.open) return null;\r\n      const ret = new ExtendedAttributes({ tokens });\r\n      ret.items = list({\r\n        parser: SimpleExtendedAttribute.parse,\r\n        listName: \"extended attribute\"\r\n      });\r\n      tokens.close = consume(\"]\") || error(\"Unexpected form of extended attribute\");\r\n      if (!ret.items.length) {\r\n        error(\"Found an empty extended attribute\");\r\n      }\r\n      return ret;\r\n    }\r\n  }\r\n\r\n  class Default extends Definition {\r\n    static parse() {\r\n      const assign = consume(\"=\");\r\n      if (!assign) {\r\n        return null;\r\n      }\r\n      const def = const_value() || consume(STR, \"null\", \"[\") || error(\"No value for default\");\r\n      const expression = [def];\r\n      if (def.type === \"[\") {\r\n        const close = consume(\"]\") || error(\"Default sequence value must be empty\");\r\n        expression.push(close);\r\n      }\r\n      return new Default({ tokens: { assign }, expression });\r\n    }\r\n\r\n    constructor({ tokens, expression }) {\r\n      super({ tokens });\r\n      Object.defineProperty(this, \"expression\", { value: expression });\r\n    }\r\n\r\n    get type() {\r\n      return const_data(this.expression[0]).type;\r\n    }\r\n    get value() {\r\n      return const_data(this.expression[0]).value;\r\n    }\r\n    get negative() {\r\n      return const_data(this.expression[0]).negative;\r\n    }\r\n    get trivia() {\r\n      const [first, second] = this.expression;\r\n      const trivia = first.type === \"[\" ? {\r\n        open: first.trivia,\r\n        close: second.trivia\r\n      } : { value: first.trivia };\r\n      return Object.assign(super.trivia, trivia);\r\n    }\r\n  }\r\n\r\n  class Constant extends Definition {\r\n    static parse() {\r\n      const tokens = {};\r\n      tokens.base = consume(\"const\");\r\n      if (!tokens.base) {\r\n        return;\r\n      }\r\n      let idlType = primitive_type();\r\n      if (!idlType) {\r\n        const base = consume(ID) || error(\"No type for const\");\r\n        idlType = new Type({ tokens: { base } });\r\n      }\r\n      if (probe(\"?\")) {\r\n        error(\"Unexpected nullable constant type\");\r\n      }\r\n      idlType.type = \"const-type\";\r\n      tokens.name = consume(ID) || error(\"No name for const\");\r\n      tokens.assign = consume(\"=\") || error(\"No value assignment for const\");\r\n      tokens.value = const_value() || error(\"No value for const\");\r\n      tokens.termination = consume(\";\") || error(\"Unterminated const\");\r\n      const ret = new Constant({ tokens });\r\n      ret.idlType = idlType;\r\n      return ret;\r\n    }\r\n\r\n    get type() {\r\n      return \"const\";\r\n    }\r\n    get name() {\r\n      return unescape(this.tokens.name.value);\r\n    }\r\n    get value() {\r\n      return const_data(this.tokens.value);\r\n    }\r\n  }\r\n\r\n  class CallbackFunction extends Definition {\r\n    static parse(base) {\r\n      const tokens = { base };\r\n      const ret = new CallbackFunction({ tokens });\r\n      tokens.name = consume(ID) || error(\"No name for callback\");\r\n      current = ret;\r\n      tokens.assign = consume(\"=\") || error(\"No assignment in callback\");\r\n      ret.idlType = return_type() || error(\"Missing return type\");\r\n      tokens.open = consume(\"(\") || error(\"No arguments in callback\");\r\n      ret.arguments = argument_list();\r\n      tokens.close = consume(\")\") || error(\"Unterminated callback\");\r\n      tokens.termination = consume(\";\") || error(\"Unterminated callback\");\r\n      return ret;\r\n    }\r\n\r\n    get type() {\r\n      return \"callback\";\r\n    }\r\n    get name() {\r\n      return unescape(this.tokens.name.value);\r\n    }\r\n  }\r\n\r\n  function callback() {\r\n    const callback = consume(\"callback\");\r\n    if (!callback) return;\r\n    const tok = consume(\"interface\");\r\n    if (tok) {\r\n      return Interface.parse(tok, { callback });\r\n    }\r\n    return CallbackFunction.parse(callback);\r\n  }\r\n\r\n  class Attribute extends Definition {\r\n    static parse({ special, noInherit = false, readonly = false } = {}) {\r\n      const start_position = consume_position;\r\n      const tokens = { special };\r\n      const ret = new Attribute({ tokens });\r\n      if (!special && !noInherit) {\r\n        tokens.special = optional_consume(\"inherit\");\r\n      }\r\n      tokens.readonly = optional_consume(\"readonly\");\r\n      if (readonly && !tokens.readonly && probe(\"attribute\")) {\r\n        error(\"Attributes must be readonly in this context\");\r\n      }\r\n      tokens.base = consume(\"attribute\");\r\n      if (!tokens.base) {\r\n        unconsume(start_position);\r\n        return;\r\n      }\r\n      ret.idlType = type_with_extended_attributes(\"attribute-type\") || error(\"No type in attribute\");\r\n      switch (ret.idlType.generic && ret.idlType.generic.value) {\r\n        case \"sequence\":\r\n        case \"record\": error(`Attributes cannot accept ${ret.idlType.generic.value} types`);\r\n      }\r\n      tokens.name = consume(ID, \"required\") || error(\"No name in attribute\");\r\n      tokens.termination = consume(\";\") || error(\"Unterminated attribute\");\r\n      return ret;\r\n    }\r\n\r\n    get type() {\r\n      return \"attribute\";\r\n    }\r\n    get special() {\r\n      return untype_token(this.tokens.special);\r\n    }\r\n    get readonly() {\r\n      return unvalue_token(this.tokens.readonly);\r\n    }\r\n    get name() {\r\n      return unescape(this.escapedName);\r\n    }\r\n    get escapedName() {\r\n      return this.tokens.name.value;\r\n    }\r\n  }\r\n\r\n  function return_type(typeName) {\r\n    const typ = type(typeName || \"return-type\");\r\n    if (typ) {\r\n      return typ;\r\n    }\r\n    const voidToken = consume(\"void\");\r\n    if (voidToken) {\r\n      const ret = new Type({ tokens: { base: voidToken } });\r\n      ret.type = \"return-type\";\r\n      return ret;\r\n    }\r\n  }\r\n\r\n  class OperationBody extends Definition {\r\n    static parse() {\r\n      const tokens = {};\r\n      const ret = new OperationBody({ tokens });\r\n      ret.idlType = return_type() || error(\"Missing return type\");\r\n      tokens.name = optional_consume(ID);\r\n      tokens.open = consume(\"(\") || error(\"Invalid operation\");\r\n      ret.arguments = argument_list();\r\n      tokens.close = consume(\")\") || error(\"Unterminated operation\");\r\n      return ret;\r\n    }\r\n\r\n    get name() {\r\n      const { name } = this.tokens;\r\n      if (!name) {\r\n        return null;\r\n      }\r\n      return {\r\n        value: unescape(name.value),\r\n        escaped: name.value,\r\n        trivia: name.trivia\r\n      };\r\n    }\r\n  }\r\n\r\n  class Operation extends Definition {\r\n    static parse({ special, regular } = {}) {\r\n      const tokens = { special };\r\n      const ret = new Operation({ tokens });\r\n      if (special && special.value === \"stringifier\") {\r\n        tokens.termination = consume(\";\");\r\n        if (tokens.termination) {\r\n          ret.body = null;\r\n          return ret;\r\n        }\r\n      }\r\n      if (!special && !regular) {\r\n        tokens.special = optional_consume(\"getter\", \"setter\", \"deleter\");\r\n      }\r\n      ret.body = OperationBody.parse();\r\n      tokens.termination = consume(\";\") || error(\"Unterminated attribute\");\r\n      return ret;\r\n    }\r\n\r\n    get type() {\r\n      return \"operation\";\r\n    }\r\n    get name() {\r\n      return (this.body && this.body.name && this.body.name.value) || \"\";\r\n    }\r\n    get special() {\r\n      return untype_token(this.tokens.special);\r\n    }\r\n  }\r\n\r\n  function static_member() {\r\n    const special = optional_consume(\"static\");\r\n    if (!special) return;\r\n    const member = Attribute.parse({ special }) ||\r\n      Operation.parse({ special }) ||\r\n      error(\"No body in static member\");\r\n    return member;\r\n  }\r\n\r\n  function stringifier() {\r\n    const special = optional_consume(\"stringifier\");\r\n    if (!special) return;\r\n    const member = Attribute.parse({ special }) ||\r\n      Operation.parse({ special }) ||\r\n      error(\"Unterminated stringifier\");\r\n    return member;\r\n  }\r\n\r\n  class IterableLike extends Definition {\r\n    static parse() {\r\n      const start_position = consume_position;\r\n      const tokens = {};\r\n      const ret = new IterableLike({ tokens });\r\n      tokens.readonly = optional_consume(\"readonly\");\r\n      tokens.base = tokens.readonly ?\r\n        consume(\"maplike\", \"setlike\") :\r\n        consume(\"iterable\", \"maplike\", \"setlike\");\r\n      if (!tokens.base) {\r\n        unconsume(start_position);\r\n        return;\r\n      }\r\n\r\n      const { type } = ret;\r\n      const secondTypeRequired = type === \"maplike\";\r\n      const secondTypeAllowed = secondTypeRequired || type === \"iterable\";\r\n\r\n      tokens.open = consume(\"<\") || error(`Error parsing ${type} declaration`);\r\n      const first = type_with_extended_attributes() || error(`Error parsing ${type} declaration`);\r\n      ret.idlType = [first];\r\n      if (secondTypeAllowed) {\r\n        first.tokens.separator = optional_consume(\",\");\r\n        if (first.separator) {\r\n          ret.idlType.push(type_with_extended_attributes());\r\n        }\r\n        else if (secondTypeRequired)\r\n          error(`Missing second type argument in ${type} declaration`);\r\n      }\r\n      tokens.close = consume(\">\") || error(`Unterminated ${type} declaration`);\r\n      tokens.termination = consume(\";\") || error(`Missing semicolon after ${type} declaration`);\r\n\r\n      return ret;\r\n    }\r\n\r\n    get type() {\r\n      return this.tokens.base.value;\r\n    }\r\n    get readonly() {\r\n      return unvalue_token(this.tokens.readonly);\r\n    }\r\n  }\r\n\r\n  class Inheritance extends Definition {\r\n    static parse() {\r\n      const colon = consume(\":\");\r\n      if (!colon) {\r\n        return;\r\n      }\r\n      const name = consume(ID) || error(\"No type in inheritance\");\r\n      return new Inheritance({ tokens: { colon, name } });\r\n    }\r\n\r\n    get name() {\r\n      return unescape(this.escapedName);\r\n    }\r\n    get escapedName() {\r\n      return this.tokens.name.value;\r\n    }\r\n  }\r\n\r\n  class Container extends Definition {\r\n    static parse(instance, { type, inheritable, allowedMembers }) {\r\n      const { tokens } = instance;\r\n      tokens.name = consume(ID) || error(\"No name for interface\");\r\n      current = instance;\r\n      if (inheritable) {\r\n        instance.inheritance = Inheritance.parse() || null;\r\n      }\r\n      tokens.open = consume(\"{\") || error(`Bodyless ${type}`);\r\n      instance.members = [];\r\n      while (true) {\r\n        tokens.close = consume(\"}\");\r\n        if (tokens.close) {\r\n          tokens.termination = consume(\";\") || error(`Missing semicolon after ${type}`);\r\n          return instance;\r\n        }\r\n        const ea = ExtendedAttributes.parse();\r\n        let mem;\r\n        for (const [parser, ...args] of allowedMembers) {\r\n          mem = parser(...args);\r\n          if (mem) {\r\n            break;\r\n          }\r\n        }\r\n        if (!mem) {\r\n          error(\"Unknown member\");\r\n        }\r\n        mem.extAttrs = ea;\r\n        instance.members.push(mem);\r\n      }\r\n    }\r\n\r\n    get partial() {\r\n      return unvalue_token(this.tokens.partial);\r\n    }\r\n    get name() {\r\n      return unescape(this.escapedName);\r\n    }\r\n    get escapedName() {\r\n      return this.tokens.name.value;\r\n    }\r\n  }\r\n\r\n  class Interface extends Container {\r\n    static parse(base, { callback = null, partial = null } = {}) {\r\n      const tokens = { callback, partial, base };\r\n      return Container.parse(new Interface({ tokens }), {\r\n        type: \"interface\",\r\n        inheritable: !partial,\r\n        allowedMembers: [\r\n          [Constant.parse],\r\n          [static_member],\r\n          [stringifier],\r\n          [IterableLike.parse],\r\n          [Attribute.parse],\r\n          [Operation.parse]\r\n        ]\r\n      });\r\n    }\r\n\r\n    get type() {\r\n      if (this.tokens.callback) {\r\n        return \"callback interface\";\r\n      }\r\n      return \"interface\";\r\n    }\r\n  }\r\n\r\n  class Mixin extends Container {\r\n    static parse(base, { partial } = {}) {\r\n      const tokens = { partial, base };\r\n      tokens.mixin = consume(\"mixin\");\r\n      if (!tokens.mixin) {\r\n        return;\r\n      }\r\n      return Container.parse(new Mixin({ tokens }), {\r\n        type: \"interface mixin\",\r\n        allowedMembers: [\r\n          [Constant.parse],\r\n          [stringifier],\r\n          [Attribute.parse, { noInherit: true }],\r\n          [Operation.parse, { regular: true }]\r\n        ]\r\n      });\r\n    }\r\n\r\n    get type() {\r\n      return \"interface mixin\";\r\n    }\r\n  }\r\n\r\n  function interface_(opts) {\r\n    const base = consume(\"interface\");\r\n    if (!base) return;\r\n    const ret = Mixin.parse(base, opts) ||\r\n      Interface.parse(base, opts) ||\r\n      error(\"Interface has no proper body\");\r\n    return ret;\r\n  }\r\n\r\n  class Namespace extends Container {\r\n    static parse({ partial } = {}) {\r\n      const tokens = { partial };\r\n      tokens.base = consume(\"namespace\");\r\n      if (!tokens.base) {\r\n        return;\r\n      }\r\n      return Container.parse(new Namespace({ tokens }), {\r\n        type: \"namespace\",\r\n        allowedMembers: [\r\n          [Attribute.parse, { noInherit: true, readonly: true }],\r\n          [Operation.parse, { regular: true }]\r\n        ]\r\n      });\r\n    }\r\n\r\n    get type() {\r\n      return \"namespace\";\r\n    }\r\n  }\r\n\r\n  function partial() {\r\n    const partial = optional_consume(\"partial\");\r\n    if (!partial) return;\r\n    return Dictionary.parse({ partial }) ||\r\n      interface_({ partial }) ||\r\n      Namespace.parse({ partial }) ||\r\n      error(\"Partial doesn't apply to anything\");\r\n  }\r\n\r\n  class Dictionary extends Container {\r\n    static parse({ partial } = {}) {\r\n      const tokens = { partial };\r\n      tokens.base = consume(\"dictionary\");\r\n      if (!tokens.base) {\r\n        return;\r\n      }\r\n      return Container.parse(new Dictionary({ tokens }), {\r\n        type: \"dictionary\",\r\n        inheritable: !partial,\r\n        allowedMembers: [\r\n          [Field.parse],\r\n        ]\r\n      });\r\n    }\r\n\r\n    get type() {\r\n      return \"dictionary\";\r\n    }\r\n  }\r\n\r\n  class Field extends Definition {\r\n    static parse() {\r\n      const tokens = {};\r\n      const ret = new Field({ tokens });\r\n      ret.extAttrs = ExtendedAttributes.parse();\r\n      tokens.required = optional_consume(\"required\");\r\n      ret.idlType = type_with_extended_attributes(\"dictionary-type\") || error(\"No type for dictionary member\");\r\n      tokens.name = consume(ID) || error(\"No name for dictionary member\");\r\n      ret.default = Default.parse();\r\n      if (tokens.required && ret.default) error(\"Required member must not have a default\");\r\n      tokens.termination = consume(\";\") || error(\"Unterminated dictionary member\");\r\n      return ret;\r\n    }\r\n\r\n    get type() {\r\n      return \"field\";\r\n    }\r\n    get name() {\r\n      return unescape(this.escapedName);\r\n    }\r\n    get escapedName() {\r\n      return this.tokens.name.value;\r\n    }\r\n    get required() {\r\n      return unvalue_token(this.tokens.required);\r\n    }\r\n  }\r\n\r\n  class Enum extends Definition {\r\n    static parse() {\r\n      const tokens = {};\r\n      tokens.base = consume(\"enum\");\r\n      if (!tokens.base) {\r\n        return;\r\n      }\r\n      tokens.name = consume(ID) || error(\"No name for enum\");\r\n      current = new Enum({ tokens });\r\n      tokens.open = consume(\"{\") || error(\"Bodyless enum\");\r\n      current.values = list({\r\n        parser: EnumValue.parse,\r\n        allowDangler: true,\r\n        listName: \"enumeration\"\r\n      });\r\n      if (probe(STR)) {\r\n        error(\"No comma between enum values\");\r\n      }\r\n      tokens.close = consume(\"}\") || error(\"Unexpected value in enum\");\r\n      if (!current.values.length) {\r\n        error(\"No value in enum\");\r\n      }\r\n      tokens.termination = consume(\";\") || error(\"No semicolon after enum\");\r\n      return current;\r\n    }\r\n\r\n    get type() {\r\n      return \"enum\";\r\n    }\r\n    get name() {\r\n      return unescape(this.escapedName);\r\n    }\r\n    get escapedName() {\r\n      return this.tokens.name.value;\r\n    }\r\n  }\r\n\r\n  class EnumValue extends Token {\r\n    static parse() {\r\n      const value = consume(STR);\r\n      if (value) {\r\n        return new EnumValue({ tokens: { value } });\r\n      }\r\n    }\r\n\r\n    get type() {\r\n      return \"enum-value\";\r\n    }\r\n    get value() {\r\n      return super.value.slice(1, -1);\r\n    }\r\n  }\r\n\r\n  class Typedef extends Definition {\r\n    static parse() {\r\n      const tokens = {};\r\n      const ret = new Typedef({ tokens });\r\n      tokens.base = consume(\"typedef\");\r\n      if (!tokens.base) {\r\n        return;\r\n      }\r\n      ret.idlType = type_with_extended_attributes(\"typedef-type\") || error(\"No type in typedef\");\r\n      tokens.name = consume(ID) || error(\"No name in typedef\");\r\n      current = ret;\r\n      tokens.termination = consume(\";\") || error(\"Unterminated typedef\");\r\n      return ret;\r\n    }\r\n\r\n    get type() {\r\n      return \"typedef\";\r\n    }\r\n    get name() {\r\n      return unescape(this.escapedName);\r\n    }\r\n    get escapedName() {\r\n      return this.tokens.name.value;\r\n    }\r\n  }\r\n\r\n  class Includes extends Definition {\r\n    static parse() {\r\n      const target = consume(ID);\r\n      if (!target) {\r\n        return;\r\n      }\r\n      const tokens = { target };\r\n      tokens.includes = consume(\"includes\");\r\n      if (!tokens.includes) {\r\n        unconsume(target.index);\r\n        return;\r\n      }\r\n      tokens.mixin = consume(ID) || error(\"Incomplete includes statement\");\r\n      tokens.termination = consume(\";\") || error(\"No terminating ; for includes statement\");\r\n      return new Includes({ tokens });\r\n    }\r\n\r\n    get type() {\r\n      return \"includes\";\r\n    }\r\n    get target() {\r\n      return unescape(this.escapedTarget);\r\n    }\r\n    get escapedTarget() {\r\n      return this.tokens.target.value;\r\n    }\r\n    get includes() {\r\n      return unescape(this.escapedIncludes);\r\n    }\r\n    get escapedIncludes() {\r\n      return this.tokens.mixin.value;\r\n    }\r\n  }\r\n\r\n  function definition() {\r\n    return callback() ||\r\n      interface_() ||\r\n      partial() ||\r\n      Dictionary.parse() ||\r\n      Enum.parse() ||\r\n      Typedef.parse() ||\r\n      Includes.parse() ||\r\n      Namespace.parse();\r\n  }\r\n\r\n  function definitions() {\r\n    if (!source.length) return [];\r\n    const defs = [];\r\n    while (true) {\r\n      const ea = ExtendedAttributes.parse();\r\n      const def = definition();\r\n      if (!def) {\r\n        if (ea) error(\"Stray extended attributes\");\r\n        break;\r\n      }\r\n      def.extAttrs = ea;\r\n      defs.push(def);\r\n    }\r\n    defs.push(consume(\"eof\"));\r\n    return defs;\r\n  }\r\n  const res = definitions();\r\n  if (consume_position < source.length) error(\"Unrecognised tokens\");\r\n  return res;\r\n}\r\n\r\nexport function parse(str) {\r\n  const tokens = tokenise(str);\r\n  return parseByTokens(tokens);\r\n}\r\n","\"use strict\";\r\n\r\nfunction noop(arg) {\r\n  return arg;\r\n}\r\n\r\nconst templates = {\r\n  wrap: items => items.join(\"\"),\r\n  trivia: noop,\r\n  name: noop,\r\n  reference: noop,\r\n  type: noop,\r\n  inheritance: noop,\r\n  definition: noop,\r\n  extendedAttribute: noop,\r\n  extendedAttributeReference: noop\r\n};\r\n\r\nexport function write(ast, { templates: ts = templates } = {}) {\r\n  ts = Object.assign({}, templates, ts);\r\n\r\n  /**\r\n   * @param {string[]} strings\r\n   * @param  {...any} args\r\n   */\r\n  function wrap(strings, ...args) {\r\n    return ts.wrap([].concat(...strings.map((s, i) => [s, args[i] || \"\"])));\r\n  }\r\n\r\n  function reference(raw, unescaped) {\r\n    return ts.reference(raw, unescaped || raw);\r\n  }\r\n\r\n  function extract_trivia(object) {\r\n    const batch = {};\r\n    for (const key in object.trivia) {\r\n      batch[key] = ts.trivia(object.trivia[key]);\r\n    }\r\n    return batch;\r\n  }\r\n\r\n  function token(t, value) {\r\n    return t ? wrap`${ts.trivia(t.trivia)}${value || t.value}` : \"\";\r\n  }\r\n\r\n  function reference_token(t, unescaped) {\r\n    return t ? wrap`${ts.trivia(t.trivia)}${reference(t.value, unescaped)}` : \"\";\r\n  }\r\n\r\n  function name_token(t, arg) {\r\n    return t ? wrap`${ts.trivia(t.trivia)}${ts.name(t.value, arg)}` : \"\";\r\n  }\r\n\r\n  function type_body(it) {\r\n    const trivia = extract_trivia(it);\r\n    if (it.union) {\r\n      const subtypes = ts.wrap(it.idlType.map(type));\r\n      return wrap`${trivia.open}(${subtypes}${trivia.close})`;\r\n    } else if (it.generic) {\r\n      const genericName = wrap`${trivia.base}${reference(it.generic.value)}`;\r\n      const subtypes = ts.wrap(it.idlType.map(type));\r\n      const gTrivia = extract_trivia(it.generic);\r\n      return wrap`${genericName}${gTrivia.open}<${subtypes}${gTrivia.close}>`;\r\n    }\r\n    if (!it.prefix && !it.postfix) {\r\n      return wrap`${trivia.base}${reference(it.escapedBaseName, it.baseName)}`;\r\n    }\r\n    const precedingTrivia = it.prefix ? ts.trivia(it.prefix.trivia) : trivia.base;\r\n    const prefix = it.prefix ? wrap`${it.prefix.value}${trivia.base}` : \"\";\r\n    const ref = reference(wrap`${prefix}${it.baseName}${token(it.postfix)}`, it.idlType);\r\n    return wrap`${precedingTrivia}${ref}`;\r\n  }\r\n  function type(it) {\r\n    const ext = extended_attributes(it.extAttrs);\r\n    const body = type_body(it);\r\n    const nullable = token(it.nullable, \"?\");\r\n    const separator = token(it.separator);\r\n    return wrap`${ext}${body}${nullable}${separator}`;\r\n  }\r\n  function default_(def) {\r\n    if (!def) {\r\n      return \"\";\r\n    }\r\n    return ts.wrap([\r\n      token(def.tokens.assign),\r\n      ...def.expression.map(t => token(t))\r\n    ]);\r\n  }\r\n  function argument(arg) {\r\n    return ts.wrap([\r\n      extended_attributes(arg.extAttrs),\r\n      token(arg.tokens.optional),\r\n      ts.type(type(arg.idlType)),\r\n      token(arg.tokens.variadic),\r\n      name_token(arg.tokens.name, { data: arg }),\r\n      default_(arg.default),\r\n      token(arg.tokens.separator)\r\n    ]);\r\n  }\r\n  function identifier(id) {\r\n    return wrap`${ts.trivia(id.trivia)}${reference(id.value)}${token(id.separator)}`;\r\n  }\r\n  function make_ext_at(it) {\r\n    const { rhsType } = it.params;\r\n    return ts.wrap([\r\n      ts.trivia(it.tokens.name.trivia),\r\n      ts.extendedAttribute(ts.wrap([\r\n        ts.extendedAttributeReference(it.name),\r\n        token(it.params.tokens.assign),\r\n        reference_token(it.params.tokens.secondaryName),\r\n        token(it.params.tokens.open),\r\n        ...!it.params.list ? [] :\r\n          it.params.list.map(\r\n            rhsType === \"identifier-list\" ? identifier : argument\r\n          ),\r\n        token(it.params.tokens.close)\r\n      ])),\r\n      token(it.tokens.separator)\r\n    ]);\r\n  }\r\n  function extended_attributes(eats) {\r\n    if (!eats) return \"\";\r\n    return ts.wrap([\r\n      token(eats.tokens.open),\r\n      ...eats.items.map(make_ext_at),\r\n      token(eats.tokens.close)\r\n    ]);\r\n  }\r\n\r\n  function operation(it, parent) {\r\n    const body = it.body ? [\r\n      ts.type(type(it.body.idlType)),\r\n      name_token(it.body.tokens.name, { data: it, parent }),\r\n      token(it.body.tokens.open),\r\n      ts.wrap(it.body.arguments.map(argument)),\r\n      token(it.body.tokens.close),\r\n    ] : [];\r\n    return ts.definition(ts.wrap([\r\n      extended_attributes(it.extAttrs),\r\n      token(it.tokens.special),\r\n      ...body,\r\n      token(it.tokens.termination)\r\n    ]), { data: it, parent });\r\n  }\r\n\r\n  function attribute(it, parent) {\r\n    return ts.definition(ts.wrap([\r\n      extended_attributes(it.extAttrs),\r\n      token(it.tokens.special),\r\n      token(it.tokens.readonly),\r\n      token(it.tokens.base),\r\n      ts.type(type(it.idlType)),\r\n      name_token(it.tokens.name, { data: it, parent }),\r\n      token(it.tokens.termination)\r\n    ]), { data: it, parent });\r\n  }\r\n\r\n  function inheritance(inh) {\r\n    if (!inh) {\r\n      return \"\";\r\n    }\r\n    return ts.wrap([\r\n      token(inh.tokens.colon),\r\n      ts.trivia(inh.tokens.name.trivia),\r\n      ts.inheritance(reference(inh.escapedName, inh.name))\r\n    ]);\r\n  }\r\n\r\n  function container(it) {\r\n    return ts.definition(ts.wrap([\r\n      extended_attributes(it.extAttrs),\r\n      token(it.tokens.partial),\r\n      token(it.tokens.base),\r\n      token(it.tokens.mixin),\r\n      name_token(it.tokens.name, { data: it }),\r\n      inheritance(it.inheritance),\r\n      token(it.tokens.open),\r\n      iterate(it.members, it),\r\n      token(it.tokens.close),\r\n      token(it.tokens.termination)\r\n    ]), { data: it });\r\n  }\r\n\r\n  function field(it, parent) {\r\n    return ts.definition(ts.wrap([\r\n      extended_attributes(it.extAttrs),\r\n      token(it.tokens.required),\r\n      ts.type(type(it.idlType)),\r\n      name_token(it.tokens.name, { data: it, parent }),\r\n      default_(it.default),\r\n      token(it.tokens.termination)\r\n    ]), { data: it, parent });\r\n  }\r\n  function const_(it, parent) {\r\n    return ts.definition(ts.wrap([\r\n      extended_attributes(it.extAttrs),\r\n      token(it.tokens.base),\r\n      ts.type(type(it.idlType)),\r\n      name_token(it.tokens.name, { data: it, parent }),\r\n      token(it.tokens.assign),\r\n      token(it.tokens.value),\r\n      token(it.tokens.termination)\r\n    ]), { data: it, parent });\r\n  }\r\n  function typedef(it) {\r\n    return ts.definition(ts.wrap([\r\n      extended_attributes(it.extAttrs),\r\n      token(it.tokens.base),\r\n      ts.type(type(it.idlType)),\r\n      name_token(it.tokens.name, { data: it }),\r\n      token(it.tokens.termination)\r\n    ]), { data: it });\r\n  }\r\n  function includes(it) {\r\n    return ts.definition(ts.wrap([\r\n      extended_attributes(it.extAttrs),\r\n      reference_token(it.tokens.target, it.target),\r\n      token(it.tokens.includes),\r\n      reference_token(it.tokens.mixin, it.includes),\r\n      token(it.tokens.termination)\r\n    ]), { data: it });\r\n  }\r\n  function callback(it) {\r\n    return ts.definition(ts.wrap([\r\n      extended_attributes(it.extAttrs),\r\n      token(it.tokens.base),\r\n      name_token(it.tokens.name, { data: it }),\r\n      token(it.tokens.assign),\r\n      ts.type(type(it.idlType)),\r\n      token(it.tokens.open),\r\n      ...it.arguments.map(argument),\r\n      token(it.tokens.close),\r\n      token(it.tokens.termination),\r\n    ]), { data: it });\r\n  }\r\n  function enum_(it) {\r\n    return ts.definition(ts.wrap([\r\n      extended_attributes(it.extAttrs),\r\n      token(it.tokens.base),\r\n      name_token(it.tokens.name, { data: it }),\r\n      token(it.tokens.open),\r\n      iterate(it.values, it),\r\n      token(it.tokens.close),\r\n      token(it.tokens.termination)\r\n    ]), { data: it });\r\n  }\r\n  function enum_value(v, parent) {\r\n    return wrap`${ts.trivia(v.trivia)}${\r\n      ts.definition(wrap`\"${ts.name(v.value, { data: v, parent })}\"`, { data: v, parent })\r\n    }${token(v.separator)}`;\r\n  }\r\n  function iterable_like(it, parent) {\r\n    return ts.definition(ts.wrap([\r\n      extended_attributes(it.extAttrs),\r\n      token(it.tokens.readonly),\r\n      token(it.tokens.base),\r\n      token(it.tokens.open),\r\n      ts.wrap(it.idlType.map(type)),\r\n      token(it.tokens.close),\r\n      token(it.tokens.termination)\r\n    ]), { data: it, parent });\r\n  }\r\n  function callbackInterface(it) {\r\n    return ts.definition(\r\n      wrap`${ts.trivia(it.trivia.callback)}callback${container(it)}`,\r\n      { data: it }\r\n    );\r\n  }\r\n  function eof(it) {\r\n    return ts.trivia(it.trivia);\r\n  }\r\n\r\n  const table = {\r\n    interface: container,\r\n    \"interface mixin\": container,\r\n    namespace: container,\r\n    operation,\r\n    attribute,\r\n    dictionary: container,\r\n    field,\r\n    const: const_,\r\n    typedef,\r\n    includes,\r\n    callback,\r\n    enum: enum_,\r\n    \"enum-value\": enum_value,\r\n    iterable: iterable_like,\r\n    legacyiterable: iterable_like,\r\n    maplike: iterable_like,\r\n    setlike: iterable_like,\r\n    \"callback interface\": callbackInterface,\r\n    eof\r\n  };\r\n  function dispatch(it, parent) {\r\n    const dispatcher = table[it.type];\r\n    if (!dispatcher) {\r\n      throw new Error(`Type \"${it.type}\" is unsupported`);\r\n    }\r\n    return table[it.type](it, parent);\r\n  }\r\n  function iterate(things, parent) {\r\n    if (!things) return;\r\n    const results = things.map(thing => dispatch(thing, parent));\r\n    return ts.wrap(results);\r\n  }\r\n  return iterate(ast);\r\n}\r\n","\"use strict\";\r\n\r\nfunction error(source, token, current, str) {\r\n  const consume_position = token.index;\r\n  const maxTokens = 5; // arbitrary but works well enough\r\n  const line =\r\n    !source[token.index].type === \"eof\" ? source[consume_position].line :\r\n    source.length > 1 ? source[consume_position - 1].line :\r\n    1;\r\n\r\n  const precedingLine = lastLine(\r\n    tokensToText(sliceTokens(-maxTokens), { precedes: true })\r\n  );\r\n\r\n  const procedingTokens = sliceTokens(maxTokens);\r\n  const procedingText = tokensToText(procedingTokens);\r\n  const procedingLine = procedingText.split(\"\\n\")[0];\r\n\r\n  const spaced = \" \".repeat(precedingLine.length) + \"^ \" + str;\r\n  const context = precedingLine + procedingLine + \"\\n\" + spaced;\r\n\r\n  const inside = current ? `, inside \\`${current.partial ? \"partial \" : \"\"}${current.type} ${current.name}\\`` : \"\";\r\n  return `Validation error at line ${line}${inside}:\\n${context}`;\r\n\r\n  function sliceTokens(count) {\r\n    return count > 0 ?\r\n      source.slice(consume_position, consume_position + count) :\r\n      source.slice(Math.max(consume_position + count, 0), consume_position);\r\n  }\r\n\r\n  function tokensToText(inputs, { precedes } = {}) {\r\n    const text = inputs.map(t => t.trivia + t.value).join(\"\");\r\n    const nextToken = source[consume_position];\r\n    if (nextToken.type === \"eof\") {\r\n      return text;\r\n    }\r\n    if (precedes) {\r\n      return text + nextToken.trivia;\r\n    }\r\n    return text.slice(nextToken.trivia.length);\r\n  }\r\n\r\n  function lastLine(text) {\r\n    const splitted = text.split(\"\\n\");\r\n    return splitted[splitted.length - 1];\r\n  }\r\n}\r\n\r\nfunction groupDefinitions(all) {\r\n  const unique = new Map();\r\n  const duplicates = new Set();\r\n  const partials = new Map();\r\n  for (const def of all) {\r\n    if (def.partial) {\r\n      const array = partials.get(def.name);\r\n      if (array) {\r\n        array.push(def);\r\n      } else {\r\n        partials.set(def.name, [def]);\r\n      }\r\n      continue;\r\n    }\r\n    if (!def.name) {\r\n      continue;\r\n    }\r\n    if (!unique.has(def.name)) {\r\n      unique.set(def.name, def);\r\n    } else {\r\n      duplicates.add(def);\r\n    }\r\n  }\r\n  return { all, unique, partials, duplicates };\r\n}\r\n\r\nfunction* checkDuplicatedNames({ unique, duplicates }) {\r\n  for (const dup of duplicates) {\r\n    const { name } = dup;\r\n    const message = `The name \"${name}\" of type \"${unique.get(name).type}\" was already seen`;\r\n    yield error(dup.source, dup.tokens.name, dup, message);\r\n  }\r\n}\r\n\r\nfunction* checkInterfaceMemberDuplication(defs) {\r\n  const interfaces = [...defs.unique.values()].filter(def => def.type === \"interface\");\r\n  const includesMap = getIncludesMap();\r\n\r\n  for (const i of interfaces) {\r\n    yield* forEachInterface(i);\r\n  }\r\n\r\n  function* forEachInterface(i) {\r\n    const opNames = new Set(getOperations(i).map(op => op.name));\r\n    const partials = defs.partials.get(i.name) || [];\r\n    const mixins = includesMap.get(i.name) || [];\r\n    for (const ext of [...partials, ...mixins]) {\r\n      const additions = getOperations(ext);\r\n      yield* forEachExtension(additions, opNames, ext, i);\r\n      for (const addition of additions) {\r\n        opNames.add(addition.name);\r\n      }\r\n    }\r\n  }\r\n\r\n  function* forEachExtension(additions, existings, ext, base) {\r\n    for (const addition of additions) {\r\n      const { name } = addition;\r\n      if (name && existings.has(name)) {\r\n        const message = `The operation \"${name}\" has already been defined for the base interface \"${base.name}\" either in itself or in a mixin`;\r\n        yield error(ext.source, addition.body.tokens.name, ext, message);\r\n      }\r\n    }\r\n  }\r\n\r\n  function getOperations(i) {\r\n    return i.members\r\n      .filter(({type}) => type === \"operation\");\r\n  }\r\n\r\n  function getIncludesMap() {\r\n    const map = new Map();\r\n    const includes = defs.all.filter(def => def.type === \"includes\");\r\n    for (const include of includes) {\r\n      const array = map.get(include.target);\r\n      const mixin = defs.unique.get(include.includes);\r\n      if (!mixin) {\r\n        continue;\r\n      }\r\n      if (array) {\r\n        array.push(mixin);\r\n      } else {\r\n        map.set(include.target, [mixin]);\r\n      }\r\n    }\r\n    return map;\r\n  }\r\n}\r\n\r\nexport function validate(ast) {\r\n  const defs = groupDefinitions(ast);\r\n  return [\r\n    ...checkDuplicatedNames(defs),\r\n    ...checkInterfaceMemberDuplication(defs)\r\n  ];\r\n}\r\n","export { parse } from \"./lib/webidl2.js\";\r\nexport { write } from \"./lib/writer.js\";\r\nexport { validate } from \"./lib/validator.js\";\r\n"],"sourceRoot":""}